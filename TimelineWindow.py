"""Macstodon - a Mastodon client for classic Mac OSMIT LicenseCopyright (c) 2022-2023 Scott Small and ContributorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associateddocumentation files (the "Software"), to deal in the Software without restriction, including without limitation therights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permitpersons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of theSoftware.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THEWARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS ORCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OROTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."""# ############### Python Imports # ##############import Listsimport Qdimport reimport stringimport urllibimport Wfrom EasyDialogs import AskString# ########### My Imports# ##########from MacstodonConstants import VERSIONfrom MacstodonHelpers import attachmentsDialog, cleanUpUnicode, dprint, handleRequest, \    ImageWidget, LinkExtractor, linksDialog, okDialog, okCancelDialog, TitledEditText, \    TimelineList# ############ Application# ###########class TimelineWindow(W.Window):    def __init__(self):        """        Initializes the TimelineWindow class.        """                # Set window size. Default to 600x400 which fits nicely in a 640x480 display.        # However if you're on a compact Mac that is 512x342, we need to make it smaller.        screenbounds = Qd.qd.screenBits.bounds        if screenbounds[2] <= 600 and screenbounds[3] <= 400:            bounds = (0, 20, 512, 342)        else:            bounds = (600, 400)                self.defaulttext = "Click on a toot or notification in one of the above lists..."        self.timelines = {            "home": [],            "local": [],            "notifications": []        }        w = W.Window.__init__(self, bounds, "Macstodon %s - Timeline" % VERSION, minsize=(512, 342))        self.setupwidgets()    # #########################    # Window Handling Functions    # #########################    def setupwidgets(self):        """        Defines the Timeline window        """        self.panes = W.HorizontalPanes((8, 8, -8, -20), (0.6, 0.4))        self.panes.tlpanes = W.VerticalPanes(None, (0.34, 0.33, 0.33))        self.panes.tlpanes.home = TimelineList(            None,            "Home Timeline",            self.timelines["home"],            btnCallback=self.refreshHomeCallback,            callback=self.homeClickCallback,            flags=Lists.lOnlyOne        )        self.panes.tlpanes.local = TimelineList(            None,            "Local Timeline",            self.timelines["local"],            btnCallback=self.refreshLocalCallback,            callback=self.localClickCallback,            flags=Lists.lOnlyOne        )        self.panes.tlpanes.notifications = TimelineList(            None,            "Notifications",            self.timelines["notifications"],            btnCallback=self.refreshNotificationsCallback,            callback=self.notificationClickCallback,            flags=Lists.lOnlyOne        )        self.panes.tootgroup = W.Group(None)        self.panes.tootgroup.toottxt = TitledEditText(            (56, 0, -24, -20),            title="",            text=self.defaulttext,            readonly=1,            vscroll=1        )        # Links and Attachment buttons        self.panes.tootgroup.links = ImageWidget(            (-20, 52, 16, 16),            pixmap=self.parent.pctLnkDis,            callback=self.linksCallback        )        self.panes.tootgroup.attch = ImageWidget(            (-20, 70, 16, 16),            pixmap=self.parent.pctAtcDis,            callback=self.attachmentsCallback        )        # Avatar, reply/boost/favourite/bookmark buttons        self.panes.tootgroup.authorimg = ImageWidget((0, 0, 24, 24), callback=self.avatarClickCallback)        self.panes.tootgroup.boosterimg = ImageWidget((24, 24, 24, 24), callback=self.boosterClickCallback)        self.panes.tootgroup.reply = ImageWidget(            (4, 52, 16, 16),            pixmap=self.parent.pctRplDis,            callback=self.replyCallback        )        self.panes.tootgroup.rpnum = W.TextBox((24, 55, 28, 16), "")        self.panes.tootgroup.favrt = ImageWidget(            (4, 70, 16, 16),            pixmap=self.parent.pctFvtDis,            callback=self.favouriteCallback        )        self.panes.tootgroup.fvnum = W.TextBox((24, 73, 28, 16), "")        self.panes.tootgroup.boost = ImageWidget(            (4, 88, 16, 16),            pixmap=self.parent.pctBstDis,            callback=self.boostCallback        )        self.panes.tootgroup.bonum = W.TextBox((24, 91, 28, 16), "")        self.panes.tootgroup.bmark = ImageWidget(            (4, 106, 16, 16),            pixmap=self.parent.pctBkmDis,            callback=self.bookmarkCallback        )        self.panes.tootgroup.logoutbutton = W.Button((56, -15, 80, 0), "Logout", self.close)        self.panes.tootgroup.prefsbutton = W.Button((146, -15, 80, 0), "Preferences", self.prefsCallback)        self.panes.tootgroup.profilebutton = W.Button((-170, -15, 80, 0), "Find User", self.profileCallback)        self.panes.tootgroup.tootbutton = W.Button((-80, -15, 80, 0), "Post Toot", self.tootCallback)    def open(self):        """        When the timeline window is opened, populate the timelines.        """        app = self.parent        prefs = app.getprefs()        W.Window.open(self)        initial_toots = int(prefs.toots_to_load_startup)        if initial_toots:            self.refreshHomeCallback(initial_toots)            self.refreshLocalCallback(initial_toots)            self.refreshNotificationsCallback(initial_toots)    def close(self):        """        When the timeline window is closed, return to the login window.        """        for window in self.parent.profilewindows.values():            window.close()        self.parent.currentuser = None        self.parent.loginwindow = self.parent.LoginWindow()        self.parent.loginwindow.open()        W.Window.close(self)    # #######################    # Menu Handling Functions    # #######################    def can_logout(self, menuitem):        """        Enable the Logout menu item when the Timeline window is open and active.        """        return 1    def domenu_logout(self, *args):        """        Log out when the Logout menu item is selected.        """        self.close()    def can_prefs(self, menuitem):        """        Enable the Preferences menu item when the Timeline window is open and active.        """        return 1    def domenu_prefs(self, *args):        """        Open the Preferences window when the Preferences menu item is selected.        """        win = self.parent.PrefsWindow()        win.open()    # ##################    # Callback Functions    # ##################    def profileCallback(self):        """        Prompt the user for a username when the Find User button is clicked        """        acctname = AskString(            "Please enter a user and domain name to view their profile.",            "username@example.com"        )        if acctname:            req_data = {                "acct": acctname            }            path = "/api/v1/accounts/lookup?%s" % urllib.urlencode(req_data)            data = handleRequest(self.parent, path)            if not data:                # handleRequest failed and should have popped an error dialog                return            if data.get("error_description") is not None:                okDialog("Server error when querying user ID:\r\r %s" % data['error_description'])            elif data.get("error") is not None:                okDialog("Server error when querying user ID:\r\r %s" % data['error'])            else:                win = self.parent.ProfileWindow(data)                win.open()    def prefsCallback(self):        """        Open the Preferences window when the Preferences button is clicked.        """        win = self.parent.PrefsWindow()        win.open()    def avatarClickCallback(self):        """        Run when clicking on a user's avatar. Opens the user's profile.        """        dprint("clicked on avatar")        toot, _, _, _ = self.getSelectedToot(resolve_boosts=1)        if toot:            win = self.parent.ProfileWindow(toot["account"])            win.open()        else:            okDialog("Please select a toot, then click on the author's avatar to view their profile.")    def boosterClickCallback(self):        dprint("clicked on booster")        toot, _, _, _ = self.getSelectedToot(resolve_boosts=0)        if toot:            win = self.parent.ProfileWindow(toot["account"])            win.open()        else:            okDialog("Please select a toot, then click on the author's avatar to view their profile.")    def timelineClickCallback(self, name):        """        Run when the user clicks somewhere in the named timeline        """        if name == "home":            list = self.panes.tlpanes.home        elif name == "local":            list = self.panes.tlpanes.local        selected = list.getselection()        if len(selected) < 1:            self.panes.tootgroup.authorimg.clearImage()            self.panes.tootgroup.boosterimg.clearImage()            self.panes.tootgroup.reply.setImage(self.parent.pctRplDis)            self.panes.tootgroup.favrt.setImage(self.parent.pctFvtDis)            self.panes.tootgroup.boost.setImage(self.parent.pctBstDis)            self.panes.tootgroup.bmark.setImage(self.parent.pctBkmDis)            self.panes.tootgroup.links.setImage(self.parent.pctLnkDis)            self.panes.tootgroup.attch.setImage(self.parent.pctAtcDis)            self.panes.tootgroup.fvnum.set("")            self.panes.tootgroup.bonum.set("")            self.panes.tootgroup.rpnum.set("")            self.panes.tootgroup.toottxt.setTitle("")            self.panes.tootgroup.toottxt.set(self.defaulttext)            return        else:            index = selected[0]            toot = self.timelines[name][index]            self.formatAndDisplayToot(toot)    def homeClickCallback(self):        """        Run when the user clicks somewhere in the home timeline        """        self.panes.tlpanes.local.setselection([-1])        self.panes.tlpanes.notifications.setselection([-1])        self.timelineClickCallback("home")    def localClickCallback(self):        """        Run when the user clicks somewhere in the local timeline        """        self.panes.tlpanes.home.setselection([-1])        self.panes.tlpanes.notifications.setselection([-1])        self.timelineClickCallback("local")    def notificationClickCallback(self):        """        Run when the user clicks somewhere in the notification timeline        """        self.panes.tlpanes.home.setselection([-1])        self.panes.tlpanes.local.setselection([-1])        list = self.panes.tlpanes.notifications        selected = list.getselection()        if len(selected) < 1:            self.panes.tootgroup.authorimg.clearImage()            self.panes.tootgroup.boosterimg.clearImage()            self.panes.tootgroup.reply.setImage(self.parent.pctRplDis)            self.panes.tootgroup.favrt.setImage(self.parent.pctFvtDis)            self.panes.tootgroup.boost.setImage(self.parent.pctBstDis)            self.panes.tootgroup.bmark.setImage(self.parent.pctBkmDis)            self.panes.tootgroup.links.setImage(self.parent.pctLnkDis)            self.panes.tootgroup.attch.setImage(self.parent.pctAtcDis)            self.panes.tootgroup.fvnum.set("")            self.panes.tootgroup.bonum.set("")            self.panes.tootgroup.rpnum.set("")            self.panes.tootgroup.toottxt.setTitle("")            self.panes.tootgroup.toottxt.set(self.defaulttext)            return        else:            index = selected[0]            notification = self.timelines["notifications"][index]            if notification["type"] in ["favourite", "reblog", "status", "mention", "poll", "update"]:                toot = notification["status"]                self.formatAndDisplayToot(toot)            elif notification["type"] == "admin.report":                okDialog("Sorry, displaying the notification type '%s' is not supported yet" % notification["type"])                self.panes.tootgroup.authorimg.clearImage()                self.panes.tootgroup.boosterimg.clearImage()                self.panes.tootgroup.reply.setImage(self.parent.pctRplDis)                self.panes.tootgroup.favrt.setImage(self.parent.pctFvtDis)                self.panes.tootgroup.boost.setImage(self.parent.pctBstDis)                self.panes.tootgroup.bmark.setImage(self.parent.pctBkmDis)                self.panes.tootgroup.links.setImage(self.parent.pctLnkDis)                self.panes.tootgroup.attch.setImage(self.parent.pctAtcDis)                self.panes.tootgroup.fvnum.set("")                self.panes.tootgroup.bonum.set("")                self.panes.tootgroup.rpnum.set("")                self.panes.tootgroup.toottxt.setTitle("")                self.panes.tootgroup.toottxt.set(self.defaulttext)            else:                win = self.parent.ProfileWindow(notification["account"])                win.open()                self.panes.tootgroup.authorimg.clearImage()                self.panes.tootgroup.boosterimg.clearImage()                self.panes.tootgroup.reply.setImage(self.parent.pctRplDis)                self.panes.tootgroup.favrt.setImage(self.parent.pctFvtDis)                self.panes.tootgroup.boost.setImage(self.parent.pctBstDis)                self.panes.tootgroup.bmark.setImage(self.parent.pctBkmDis)                self.panes.tootgroup.links.setImage(self.parent.pctLnkDis)                self.panes.tootgroup.attch.setImage(self.parent.pctAtcDis)                self.panes.tootgroup.fvnum.set("")                self.panes.tootgroup.bonum.set("")                self.panes.tootgroup.rpnum.set("")                self.panes.tootgroup.toottxt.setTitle("")                self.panes.tootgroup.toottxt.set(self.defaulttext)    def refreshHomeCallback(self, limit=None):        """        Run when the user clicks the Refresh button above the home timeline        """        self.updateTimeline("home", limit)        self.panes.tlpanes.home.set(self.formatTimelineForList("home"))    def refreshLocalCallback(self, limit=None):        """        Run when the user clicks the Refresh button above the local timeline        """        self.updateTimeline("local", limit)        self.panes.tlpanes.local.set(self.formatTimelineForList("local"))    def refreshNotificationsCallback(self, limit=None):        """        Run when the user clicks the Refresh button above the notifications timeline        """        self.updateTimeline("notifications", limit)        listitems = self.formatNotificationsForList()        self.panes.tlpanes.notifications.set(listitems)    def tootCallback(self):        """        Run when the user clicks the "Post Toot" button from the timeline window.        It opens up the toot window.        """        self.parent.tootwindow = self.parent.TootWindow()        self.parent.tootwindow.open()    def replyCallback(self):        """        Run when the user clicks the "Reply" button from the timeline window.        It opens up the toot window, passing the currently selected toot as a parameter.        """        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            self.parent.tootwindow = self.parent.TootWindow(replyTo=toot)            self.parent.tootwindow.open()        else:            okDialog("Please select a toot first.")    def boostCallback(self):        """        Boosts a toot. Removes the boost if the toot was already boosted.        """        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            if toot["reblogged"]:                # already boosted, undo it                action = "unreblog"                req_data = {}            else:                # not boosted yet                action = "reblog"                visibility = toot["visibility"]                if visibility == "limited" or visibility == "direct":                    visibility = "public"                req_data = {                    "visibility": visibility                }            path = "/api/v1/statuses/%s/%s" % (toot["id"], action)            data = handleRequest(self.parent, path, req_data, use_token=1)            if not data:                # handleRequest failed and should have popped an error dialog                return            if data.get("error_description") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action, data['error_description']))            elif data.get("error") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action, data['error']))            else:                if action == "reblog":                    if origToot:                        if origToot.get("reblog"):                            dprint("overwriting boosted toot")                            timeline[index]["reblog"] = data["reblog"]                        else:                            dprint("overwriting notification")                            timeline[index]["status"] = data["reblog"]                    else:                        dprint("overwriting normal toot")                        timeline[index] = data["reblog"]                    self.panes.tootgroup.boost.setImage(self.parent.pctBstClr)                else:                    if origToot:                        if origToot.get("reblog"):                            if origToot["account"]["id"] != self.parent.currentuser["id"]:                                dprint("overwriting boosted toot by another user")                                timeline[index]["reblog"] = data                            else:                                dprint("own boosted toot, need to remove from timeline")                                del timeline[index]                                self.panes.tlpanes.timeline.set(self.formatTimelineForList())                        else:                            dprint("overwriting notification")                            timeline[index]["status"] = data                    else:                        dprint("overwriting normal toot")                        timeline[index] = data                    self.panes.tootgroup.boost.setImage(self.parent.pctBstBnW)                okDialog("Toot %sged successfully!" % action)        else:            okDialog("Please select a toot first.")    def favouriteCallback(self):        """        Favourites a toot. Removes the favourite if the toot was already favourited.        """        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            if toot["favourited"]:                # already favourited, undo it                action = "unfavourite"            else:                # not favourited yet                action = "favourite"            path = "/api/v1/statuses/%s/%s" % (toot["id"], action)            data = handleRequest(self.parent, path, {}, use_token=1)            if not data:                # handleRequest failed and should have popped an error dialog                return            if data.get("error_description") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action[:-1], data['error_description']))            elif data.get("error") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action[:-1], data['error']))            else:                if origToot:                    if origToot.get("reblog"):                        dprint("overwriting boosted toot")                        timeline[index]["reblog"] = data                    else:                        dprint("overwriting notification")                        timeline[index]["status"] = data                else:                    dprint("overwriting normal toot")                    timeline[index] = data                okDialog("Toot %sd successfully!" % action)                if action == "favourite":                    self.panes.tootgroup.favrt.setImage(self.parent.pctFvtClr)                else:                    self.panes.tootgroup.favrt.setImage(self.parent.pctFvtBnW)        else:            okDialog("Please select a toot first.")    def bookmarkCallback(self):        """        Bookmarks a toot. Removes the bookmark if the toot was already bookmarked.        """        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            if toot["bookmarked"]:                # already bookmarked, undo it                action = "unbookmark"            else:                # not bookmarked yet                action = "bookmark"            path = "/api/v1/statuses/%s/%s" % (toot["id"], action)            data = handleRequest(self.parent, path, {}, use_token=1)            if not data:                # handleRequest failed and should have popped an error dialog                return            if data.get("error_description") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action, data['error_description']))            elif data.get("error") is not None:                okDialog("Server error when %sing toot:\r\r %s" % (action, data['error']))            else:                if origToot:                    if origToot.get("reblog"):                        dprint("overwriting boosted toot")                        timeline[index]["reblog"] = data                    else:                        dprint("overwriting notification")                        timeline[index]["status"] = data                else:                    dprint("overwriting normal toot")                    timeline[index] = data                okDialog("Toot %sed successfully!" % action)                if action == "bookmark":                    self.panes.tootgroup.bmark.setImage(self.parent.pctBkmClr)                else:                    self.panes.tootgroup.bmark.setImage(self.parent.pctBkmBnW)        else:            okDialog("Please select a toot first.")    def linksCallback(self):        """        Displays a dialog containing the links in the toot and allows the user to open them.        """        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            content = toot["content"]            # Replace HTML linebreak tags with actual linebreaks            content = cleanUpUnicode(content)            # Extract links            le = LinkExtractor()            le.feed(content)            le.close()            linksDialog(le)        else:            okDialog("Please select a toot first.")    def attachmentsCallback(self):        toot, origToot, timeline, index = self.getSelectedToot(resolve_boosts=1)        if toot:            attachmentsDialog(toot["media_attachments"])        else:            okDialog("Please select a toot first.")    # ####################    # Formatting Functions    # ####################    def formatAndDisplayToot(self, toot):        """        Formats a toot for display and displays it in the bottom third        """        prefs = self.parent.getprefs()                # clear existing toot        self.panes.tootgroup.authorimg.clearImage()        self.panes.tootgroup.boosterimg.clearImage()        self.panes.tootgroup.reply.setImage(self.parent.pctRplDis)        self.panes.tootgroup.favrt.setImage(self.parent.pctFvtDis)        self.panes.tootgroup.boost.setImage(self.parent.pctBstDis)        self.panes.tootgroup.bmark.setImage(self.parent.pctBkmDis)        self.panes.tootgroup.links.setImage(self.parent.pctLnkDis)        self.panes.tootgroup.attch.setImage(self.parent.pctAtcDis)        self.panes.tootgroup.fvnum.set("")        self.panes.tootgroup.bonum.set("")        self.panes.tootgroup.rpnum.set("")        self.panes.tootgroup.toottxt.setTitle("")        self.panes.tootgroup.toottxt.set("Loading toot...")        display_name = toot["account"]["display_name"] or toot["account"]["username"]        display_name = cleanUpUnicode(display_name)        if toot["reblog"]:            self.panes.tootgroup.authorimg.resize(24,24)            if prefs.show_avatars:                image = self.parent.imagehandler.getImageFromURL(toot["reblog"]["account"]["avatar"], "account")                bimage = self.parent.imagehandler.getImageFromURL(toot["account"]["avatar"], "account")            else:                image = None                bimage = None            reblog_display_name = toot["reblog"]["account"]["display_name"] or toot["reblog"]["account"]["username"]            reblog_display_name = cleanUpUnicode(reblog_display_name)            title = "%s boosted %s (@%s)" % (display_name, reblog_display_name, toot["reblog"]["account"]["acct"])            content = toot["reblog"]["content"]            sensitive = toot["reblog"]["sensitive"]            spoiler_text = toot["reblog"]["spoiler_text"]            favourites_count = toot["reblog"]["favourites_count"]            reblogs_count = toot["reblog"]["reblogs_count"]            replies_count = toot["reblog"]["replies_count"]            favourited = toot["reblog"]["favourited"]            reblogged = toot["reblog"]["reblogged"]            bookmarked = toot["reblog"]["bookmarked"]        else:            self.panes.tootgroup.authorimg.resize(48,48)            if prefs.show_avatars:                image = self.parent.imagehandler.getImageFromURL(toot["account"]["avatar"], "account")            else:                image = None            bimage = None            title = "%s (@%s)" % (display_name, toot["account"]["acct"])            content = toot["content"]            sensitive = toot["sensitive"]            spoiler_text = toot["spoiler_text"]            favourites_count = toot["favourites_count"]            reblogs_count = toot["reblogs_count"]            replies_count = toot["replies_count"]            favourited = toot["favourited"]            reblogged = toot["reblogged"]            bookmarked = toot["bookmarked"]        # Check for CW        if sensitive:            cwText = "This toot has a content warning. " \                "Press OK to view or Cancel to not view.\r\r%s"            try:                okCancelDialog(cwText % spoiler_text)            except KeyboardInterrupt:                self.panes.tootgroup.toottxt.set(self.defaulttext)                return        # Replace HTML linebreak tags with actual linebreaks        content = cleanUpUnicode(content)        content = string.replace(content, "<br>", "\r")        content = string.replace(content, "<br/>", "\r")        content = string.replace(content, "<br />", "\r")        content = string.replace(content, "<p>", "")        content = string.replace(content, "</p>", "\r\r")        # Extract links        le = LinkExtractor()        le.feed(content)        le.close()        # Strip all other HTML tags        content = re.sub('<[^<]+?>', '', content)        # Render content into UI        if image:            self.panes.tootgroup.authorimg.setImage(image)        if bimage:            self.panes.tootgroup.boosterimg.setImage(bimage)        self.panes.tootgroup.reply.setImage(self.parent.pctRplBnW)        if favourited:            self.panes.tootgroup.favrt.setImage(self.parent.pctFvtClr)        else:            self.panes.tootgroup.favrt.setImage(self.parent.pctFvtBnW)        if reblogged:            self.panes.tootgroup.boost.setImage(self.parent.pctBstClr)        else:            self.panes.tootgroup.boost.setImage(self.parent.pctBstBnW)        if bookmarked:            self.panes.tootgroup.bmark.setImage(self.parent.pctBkmClr)        else:            self.panes.tootgroup.bmark.setImage(self.parent.pctBkmBnW)        self.panes.tootgroup.links.setImage(self.parent.pctLnkBnW)        self.panes.tootgroup.attch.setImage(self.parent.pctAtcBnW)        self.panes.tootgroup.toottxt.setTitle(title)        self.panes.tootgroup.toottxt.set(content)        self.panes.tootgroup.fvnum.set(str(favourites_count))        self.panes.tootgroup.bonum.set(str(reblogs_count))        self.panes.tootgroup.rpnum.set(str(replies_count))    def formatTimelineForList(self, name):        """        Formats toots for display in a timeline list        """        listitems = []        for toot in self.timelines[name]:            if toot["reblog"]:                if toot["reblog"]["sensitive"]:                    content = toot["reblog"]["spoiler_text"]                else:                    content = toot["reblog"]["content"]            else:                if toot["sensitive"]:                    content = toot["spoiler_text"]                else:                    content = toot["content"]                        content = cleanUpUnicode(content)                        # Replace linebreaks with spaces            content = string.replace(content, "<br>", " ")            content = string.replace(content, "<br/>", " ")            content = string.replace(content, "<br />", " ")            content = string.replace(content, "<p>", "")            content = string.replace(content, "</p>", " ")                        # Strip all other HTML tags            content = re.sub('<[^<]+?>', '', content)            display_name = toot["account"]["display_name"] or toot["account"]["username"]            display_name = cleanUpUnicode(display_name)            if toot["reblog"]:                reblog_display_name = toot["reblog"]["account"]["display_name"] or toot["reblog"]["account"]["username"]                reblog_display_name = cleanUpUnicode(reblog_display_name)                listitem = "%s boosted %s\r%s" % (display_name, reblog_display_name, content)            else:                listitem = "%s\r%s" % (display_name, content)            listitems.append(listitem)        return listitems    def formatNotificationsForList(self):        """        Formats notifications for display in a list        """        listitems = []        for notification in self.timelines["notifications"]:            display_name = notification["account"]["display_name"] or notification["account"]["username"]            display_name = cleanUpUnicode(display_name)            if notification["type"] == "mention":                listitem = "%s mentioned you in their toot" % display_name            elif notification["type"] == "status":                listitem = "%s posted a toot" % display_name            elif notification["type"] == "reblog":                listitem = "%s boosted your toot" % display_name            elif notification["type"] == "follow":                listitem = "%s followed you" % display_name            elif notification["type"] == "follow_request":                listitem = "%s requested to follow you" % display_name            elif notification["type"] == "favourite":                listitem = "%s favourited your toot" % display_name            elif notification["type"] == "poll":                listitem = "%s's poll has ended" % display_name            elif notification["type"] == "update":                listitem = "%s updated their toot" % display_name            elif notification["type"] == "admin.sign_up":                listitem = "%s signed up" % display_name            elif notification["type"] == "admin.report":                listitem = "%s filed a report" % display_name            else:                # unknown type, ignore it, but print to console if debugging                dprint("Unknown notification type: %s" % notification["type"])            listitems.append(listitem)        return listitems    # ################    # Helper Functions    # ################    def getSelectedToot(self, resolve_boosts=0):        """        Returns the selected toot, the containing toot (if boost or notification),        the timeline to which the toot belongs, and the index of the toot in the timeline.        """        homeTimeline = self.panes.tlpanes.home        localTimeline = self.panes.tlpanes.local        notificationsTimeline = self.panes.tlpanes.notifications        homeSelected = homeTimeline.getselection()        localSelected = localTimeline.getselection()        notificationsSelected = notificationsTimeline.getselection()        if len(homeSelected) > 0:            index = homeSelected[0]            toot = self.timelines["home"][index]            timeline = self.timelines["home"]        elif len(localSelected) > 0:            index = localSelected[0]            toot = self.timelines["local"][index]            timeline = self.timelines["local"]        elif len(notificationsSelected) > 0:            index = notificationsSelected[0]            toot = self.timelines["notifications"][index]            timeline = self.timelines["notifications"]        else:            return None, None, None, None        if toot.get("reblog") and resolve_boosts:            return toot["reblog"], toot, timeline, index        elif toot.get("status"):            return toot["status"], toot, timeline, index        else:            return toot, None, timeline, index    def updateTimeline(self, name, limit = None):        """        Pulls a timeline from the server and updates the global dicts                TODO: hashtags and lists        """        params = {}        app = self.parent        prefs = app.getprefs()        if limit:            # If a limit was explicitly set in the call, use that            params["limit"] = limit        else:            # Otherwise, use the refresh limit from the prefs if one was set            refresh_toots = int(prefs.toots_to_load_refresh)            if refresh_toots:                params["limit"] = refresh_toots        if len(self.timelines[name]) > 0:            params["min_id"] = self.timelines[name][0]["id"]        if name == "home":            path = "/api/v1/timelines/home"        elif name == "local":            path = "/api/v1/timelines/public"            params["local"] = "true"        elif name == "public":            # not currently used anywhere            path = "/api/v1/timelines/public"        elif name == "notifications":            path = "/api/v1/notifications"        else:            dprint("Unknown timeline name: %s" % name)            return        encoded_params = urllib.urlencode(params)        if encoded_params:            path = path + "?" + encoded_params        data = handleRequest(self.parent, path, use_token=1)        if not data:            # handleRequest failed and should have popped an error dialog            return        # if data is a list, it worked        if type(data) == type([]):            for i in range(len(data)-1, -1, -1):                self.timelines[name].insert(0, data[i])                self.timelines[name] = self.timelines[name][:int(prefs.toots_per_timeline)]        # if data is a dict, it failed        elif type(data) == type({}) and data.get("error") is not None:            okDialog("Server error when refreshing %s timeline:\r\r %s" % (name, data['error']))        # i don't think this is reachable, but just in case...        else:            okDialog("Server error when refreshing %s timeline. Unable to determine data type." % name)